diff --git a/crates/l2/prover/src/backend/sp1.rs b/crates/l2/prover/src/backend/sp1.rs
index b336ffb91..e5a7b13c6 100644
--- a/crates/l2/prover/src/backend/sp1.rs
+++ b/crates/l2/prover/src/backend/sp1.rs
@@ -77,7 +77,12 @@ impl ProveOutput {
     }
 }
 
-pub fn execute(input: ProgramInput) -> Result<(), Box<dyn std::error::Error>> {
+pub struct ExecutionResult {
+    pub total_cycles: u64,
+    pub total_syscalls: u64,
+}
+
+pub fn execute(input: ProgramInput) -> Result<ExecutionResult, Box<dyn std::error::Error>> {
     let mut stdin = SP1Stdin::new();
     let bytes = rkyv::to_bytes::<Error>(&input)?;
     stdin.write_slice(bytes.as_slice());
@@ -85,12 +90,20 @@ pub fn execute(input: ProgramInput) -> Result<(), Box<dyn std::error::Error>> {
     let setup = PROVER_SETUP.get_or_init(|| init_prover_setup(None));
 
     let now = Instant::now();
-    setup.client.execute(ZKVM_SP1_PROGRAM_ELF, &stdin)?;
+    let (_, report) = setup.client.execute(ZKVM_SP1_PROGRAM_ELF, &stdin)?;
     let elapsed = now.elapsed();
 
+    let total_cycles = report.total_instruction_count();
+    let total_syscalls = report.total_syscall_count();
+
     info!("Successfully executed SP1 program in {elapsed:.2?}");
+    info!("Total cycles: {}", total_cycles);
+    info!("Total syscalls: {}", total_syscalls);
 
-    Ok(())
+    Ok(ExecutionResult {
+        total_cycles,
+        total_syscalls,
+    })
 }
 
 pub fn prove(
diff --git a/crates/l2/prover/src/lib.rs b/crates/l2/prover/src/lib.rs
index fdff0da19..a0a01d7a0 100644
--- a/crates/l2/prover/src/lib.rs
+++ b/crates/l2/prover/src/lib.rs
@@ -9,19 +9,37 @@ use tracing::warn;
 
 use crate::backend::{Backend, ProveOutput};
 
+#[derive(Debug, Clone)]
+pub struct ExecutionMetrics {
+    pub total_cycles: u64,
+    pub total_syscalls: u64,
+}
+
 pub async fn init_client(config: ProverConfig) {
     prover::start_prover(config).await;
     warn!("Prover finished!");
 }
 
 /// Execute a program using the specified backend.
-pub fn execute(backend: Backend, input: ProgramInput) -> Result<(), Box<dyn std::error::Error>> {
+pub fn execute(backend: Backend, input: ProgramInput) -> Result<ExecutionMetrics, Box<dyn std::error::Error>> {
     match backend {
-        Backend::Exec => backend::exec::execute(input),
+        Backend::Exec => {
+            backend::exec::execute(input)?;
+            Ok(ExecutionMetrics { total_cycles: 0, total_syscalls: 0 })
+        },
         #[cfg(feature = "sp1")]
-        Backend::SP1 => backend::sp1::execute(input),
+        Backend::SP1 => {
+            let result = backend::sp1::execute(input)?;
+            Ok(ExecutionMetrics { 
+                total_cycles: result.total_cycles, 
+                total_syscalls: result.total_syscalls 
+            })
+        },
         #[cfg(feature = "risc0")]
-        Backend::RISC0 => backend::risc0::execute(input),
+        Backend::RISC0 => {
+            backend::risc0::execute(input)?;
+            Ok(ExecutionMetrics { total_cycles: 0, total_syscalls: 0 })
+        },
     }
 }
 
